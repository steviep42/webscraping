[
["xml.html", "Chapter 2 XML and JSON 2.1 Finding XPaths 2.2 Example: GeoCoding With Google 2.3 Using JSON 2.4 Using the RJSONIO Package", " Chapter 2 XML and JSON This is where things get a little dicey because some web pages will return XML and JSON in response to inquiries and while these formats seem complicated they are actually doing you a really big favor by doing this since these formats can ususally be easily parsed using various packges. XML is a bit hard to get your head around and JSON is the new kid on the block which is easier to use. Since this isn’t a full-on course lecture I’ll keep it short as to how and why you would want to use these but any time you spend trying to better understand JSON (and XML) the better of you will be when parsing web pages. It’s not such a big deal if all you are going to be parsing is raw text since the mthods we use to do that avoid XML and JSON although cleaning up raw text has its own problems. Let’s revisit the Wikipedia example from the previous section. library(rvest) ## Loading required package: xml2 # Use read_html to fetch the webpage url &lt;- &quot;https://en.wikipedia.org/wiki/World_population&quot; ten_most_df &lt;- read_html(url) ten_most_populous &lt;- ten_most_df %&gt;% html_nodes(&quot;table&quot;) %&gt;% `[[`(6) %&gt;% html_table() Let’s look at an XML file that has some basic content: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;bookstore&gt; &lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; Well we pulled out all tables and then, by experimentation, we isolated table 6 and got the content corresponding to that. But. Is there a more direct way to find the content ? There is. It requires us to install some helper plugins such as the xPath Finder for Firefox and Chrome. In reality there are a number of ways to find the XML Path or CSS Path for an element within a web page but this is a good one to start. Remeber that we want to find the table corresponding to the “10 Most Populous Countries”. So we activate the xPath finder plugin and the highlight the element of interest. This takes some practice to get it right. Once you highlight the desired elment you will see the corresponding XPATH. Here is a screenshot of what I did. We can use the resulting path to directly access the table without first having to first pull out all tables and then trying to find the right one # Use read_html to fetch the webpage url &lt;- &quot;https://en.wikipedia.org/wiki/World_population&quot; ten_most_populous &lt;- read_html(url) ten_most_df &lt;- ten_most_populous %&gt;% html_nodes(xpath=&#39;/html/body/div[3]/div[3]/div[4]/div/table[5]&#39;) %&gt;% html_table() # We have to get the first element of the list. ten_most_df &lt;- ten_most_df[[1]] ten_most_df ## Rank Country / Territory Population Date ## 1 1 China[note 4] 1,395,120,000 November 11, 2018 ## 2 2 India 1,339,420,000 November 11, 2018 ## 3 3 United States 328,156,000 November 11, 2018 ## 4 4 Indonesia 265,015,300 July 1, 2018 ## 5 5 Pakistan 212,742,631 May 25, 2017 ## 6 6 Brazil 209,833,000 November 11, 2018 ## 7 7 Nigeria 188,500,000 October 31, 2016 ## 8 8 Bangladesh 165,514,000 November 11, 2018 ## 9 9 Russia[note 5] 146,877,088 January 1, 2018 ## 10 10 Japan 126,440,000 October 1, 2018 ## % of worldpopulation Source ## 1 18.2% [82] ## 2 17.5% [83] ## 3 4.28% [84] ## 4 3.46% [85] ## 5 2.78% [86] ## 6 2.74% [87] ## 7 2.46% [88] ## 8 2.16% [89] ## 9 1.92% [90] ## 10 1.65% [91] 2.1 Finding XPaths In addition to Browser Plugins there are standalone tools such as the Oxygen XML Editor which is availabel through the Emory Software Express Website. This is a comprehensive XML editor that will allow you to parse XML and develop paths to locate specific nodes within an XML document. If you find yourself working with websites with lots of XML then this will be useful. The Oxygen editor is free. Let’s look at an XML file that has some basic content: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;bookstore&gt; &lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 2.2 Example: GeoCoding With Google Let’s run through an example of using the GeoCoding API with Google. They used to provide free access to this service and they still do although you are limited to a certain number. You have to sign up for an account and get an API key. Anyway, let’s run through this example and then look at how I parsed the XML file that is returned by the Google GeoCoding API. Let’s say that we wanted to get the latitude and longitude associated with the the address 1510 Clifton Rd, Atlanta, GA which corresponds to the Rollins Research Building. First we will see an example of what Google returns in terms of XML. We can use some tools like Oxygen Editor (available free via Emory Software Express) to develop an appropriate XPATH expression to parse out the latitude and longitude information. # https://maps.googleapis.com/maps/api/geocode/xml?address=1510+Clifton+Road,+Atlanta,+GA&amp;key=AIzaSyAbhVdPH0wDVWUayUaj5N4r379Fbkq5NBM # https://maps.googleapis.com/maps/api/geocode/json?address=1510+Clifton+Road,+Atlanta,+GA&amp;key=AIzaSyAbhVdPH0wDVWUayUaj5N4r379Fbkq5NBM myGeo &lt;- function(address=&quot;1510 Clifton Rd Atlanta GA&quot;,form=&quot;xml&quot;) { library(XML) library(RCurl) geourl &lt;- &quot;https://maps.googleapis.com/maps/api/geocode/&quot; key &lt;- &quot;AIzaSyAbhVdPH0wDVWUayUaj5N4r379Fbkq5NBM&quot; address &lt;- gsub(&quot; &quot;,&quot;+&quot;,address) add &lt;- paste0(geourl,form,sep=&quot;?address=&quot;) add &lt;- paste0(add,address,&quot;&amp;key=&quot;) geourl &lt;- paste0(add,key) locale &lt;- getURL(geourl) plocal &lt;- xmlParse(locale,useInternalNodes=TRUE) # Okay let&#39;s extract the lat and lon latlon &lt;- getNodeSet(plocal,&quot;/GeocodeResponse/result/geometry/location/descendant::*&quot;) lat &lt;- as.numeric(xmlSApply(latlon,xmlValue))[1] lon &lt;- as.numeric(xmlSApply(latlon,xmlValue))[2] return(c(lat=lat,lng=lon)) } myGeo() ## lat lng ## 33.79667 -84.32319 Now. We could have saved the report to a file on our local computer and open it up with Oxygen editor and figure out what the approproate XPATH would be. This is basically what I did. Here is a screenshot of the session: We could expand this considerable to process a number of addresses: namevec &lt;- c(&quot;Atlanta GA&quot;, &quot;Birmingham AL&quot;, &quot;Seattle WA&quot;, &quot;Sacramento CA&quot;, &quot;Denver CO&quot;, &quot;LosAngeles CA&quot;, &quot;Rochester NY&quot;) cityList &lt;- lapply(namevec,myGeo) # Or to get a data frame cities &lt;- data.frame(city=namevec,do.call(rbind,cityList), stringsAsFactors = FALSE) cities ## city lat lng ## 1 Atlanta GA 33.74900 -84.38798 ## 2 Birmingham AL 33.51859 -86.81036 ## 3 Seattle WA 47.60621 -122.33207 ## 4 Sacramento CA 38.58157 -121.49440 ## 5 Denver CO 39.73924 -104.99025 ## 6 LosAngeles CA 34.05223 -118.24368 ## 7 Rochester NY 43.15658 -77.60885 # Let&#39;s create a Map library(leaflet) m &lt;- leaflet(data=cities) m &lt;- addTiles(m) m &lt;- addMarkers(m,popup=cities$city) # Put up the Map - click on the markers m 2.3 Using JSON JSON is fast becoming the primary interchange format over XML although XML is still well supported. R has a number of packages to ease the parsing of JSON/ documents returned by web pages. Ususally you get back a list which is a native data type in R that can easily be manipulated into a data frame. Most web APIs provide an option for JSON or XML although some only provide JSON. There are rules and regulations about how JSON is formed and we will learn them by example but you can look at the numerous tutotorials on the web to locate definitive references. See http://www.w3schools.com/json/ Here is an XML file that describes some employees. &lt;employees&gt; &lt;employee&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Doe&lt;/lastName&gt; &lt;/employee&gt; &lt;employee&gt; &lt;firstName&gt;Anna&lt;/firstName&gt; &lt;lastName&gt;Smith&lt;/lastName&gt; &lt;/employee&gt; &lt;employee&gt; &lt;firstName&gt;Peter&lt;/firstName&gt; &lt;lastName&gt;Jones&lt;/lastName&gt; &lt;/employee&gt; &lt;/employees&gt; And here is the corresposning JSON file: { &quot;employees&quot;:[ {&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;}, {&quot;firstName&quot;:&quot;Anna&quot;, &quot;lastName&quot;:&quot;Smith&quot;}, {&quot;firstName&quot;:&quot;Peter&quot;,&quot;lastName&quot;:&quot;Jones&quot;} ] } It is important to note that the actual information in the document, things like city name, county name, latitude, and longitude are the same as they would be in the comparable XML document. JSON documents are at the heart of the NoSQL“database”called MongoDB JSON can be found within many webpages since it is closely related to JavaScript which is a language strongly related to web pages. JSON is very compact and lighweight which has made it a natural followon to XML so much so that it appears to be replacing XML See http:..www.json.org/ for a full description of the specification An object is an unordered set of name/value pairs. An object begins with (left brace) and ends with (right brace). Each name is followed by : (colon) and the name/value pairs are separated by , (comma). An array is an ordered collection of values. An array begins with [ (left bracket) and ends with ] (right bracket). Values are separated by , (comma). A value can be a string in double quotes, or a number, or true or false or null, or an object or an array. These structures can be nested. A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A character is represented as a single character string. Do you remember the Google Geocding example from before ? We can tell Google to send us back JSON instead of XML just by adjusting the URL accordingly: url &lt;- &quot;https://maps.googleapis.com/maps/api/geocode/json?address=1510+Clifton+Rd+Atlanta+GA&amp;key=AIzaSyAbhVdPH0wDVWUayUaj5N4r379Fbkq5NBM&quot; 2.4 Using the RJSONIO Package To read/parse this in R we use a package called RJSONIO. There are other packages but this is the one we will be using. Download and install it. There is a function called fromJSON which will parse the JSON file and return a list to contain the data. So we parse lists instead of using XPath. Many people feel this to be easier than trying to construct XPath statments. You will have to decide for yourself. library(RJSONIO) geo &lt;- fromJSON(url) str(geo,3) ## List of 2 ## $ results:List of 1 ## ..$ :List of 6 ## .. ..$ address_components:List of 7 ## .. ..$ formatted_address : chr &quot;1510 Clifton Rd, Atlanta, GA 30322, USA&quot; ## .. ..$ geometry :List of 3 ## .. ..$ place_id : chr &quot;ChIJ5QjdF_oG9YgRWAJzCm19Vf8&quot; ## .. ..$ plus_code : Named chr [1:2] &quot;QMWG+MP Druid Hills, Georgia, United States&quot; &quot;865QQMWG+MP&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;compound_code&quot; &quot;global_code&quot; ## .. ..$ types : chr &quot;street_address&quot; ## $ status : chr &quot;OK&quot; Since what we get back is a list we can directly access whatever we want. We just index into the list. No need for complicated XPATHS. geo$results[[1]]$geometry$location ## lat lng ## 33.79667 -84.32319 "]
]
